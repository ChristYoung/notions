(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{333:function(t,a,s){"use strict";s.r(a);var e=s(14),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"遍历时key的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历时key的作用"}},[t._v("#")]),t._v(" 遍历时Key的作用")]),t._v(" "),a("p",[t._v("在React中，使用"),a("code",[t._v("map")]),t._v("方法遍历数组时，需要为每个元素添加一个唯一的"),a("code",[t._v("key")]),t._v("属性。这个"),a("code",[t._v("key")]),t._v("属性用于标识每个元素，以便在更新组件时确定哪些元素需要更新。")]),t._v(" "),a("p",[t._v("在遍历过程中，每个元素的"),a("code",[t._v("key")]),t._v("属性应该具有唯一性，并且应该与元素在数组中的位置无关。这样可以确保在更新组件时，React能够正确地识别和更新每个元素。")]),t._v(" "),a("p",[t._v("在实际开发中，通常使用数组的索引作为元素的"),a("code",[t._v("key")]),t._v("属性，但是这样做可能会导致性能问题。因为当数组发生变化时，React会尝试重新排序元素，这将导致性能下降。因此，建议使用唯一标识符作为元素的"),a("code",[t._v("key")]),t._v("属性，例如使用"),a("code",[t._v("id")]),t._v("属性或者生成一个唯一的"),a("code",[t._v("key")]),t._v("属性。")]),t._v(" "),a("p",[t._v("在React中，key是非常重要的属性，它用于识别哪些元素发生了变化。你提到的用index作为key值的方法，在特定情况下可能会导致一些问题。我们详细讨论一下用index作为key的影响以及潜在的问题。")]),t._v(" "),a("h2",{attrs:{id:"使用index作为key的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用index作为key的影响"}},[t._v("#")]),t._v(" 使用index作为key的影响")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("基本行为：\n当你用index作为key值时，每次列表项的顺序改变时，index的值也会相应改变。比如，假设你有一个列表：")])])])]),t._v(" "),a("p",[t._v("javascript\nCopy code\nconst items = [\n{ key: 'item1', value: 'Value 1' },\n{ key: 'item2', value: 'Value 2' },\n];\n如果你用index作为key值：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("OverlapItem\n    key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 index 作为 key")]),t._v("\n    data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    removeItem"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("removeItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    moveItemUp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("moveItemUp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    moveItemDown"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("moveItemDown"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在初始状态下，index为0和1；当你移动项目时，index也会相应改变。React在渲染过程中，key的值不再是固定的item.key，而是依赖于index。")]),t._v(" "),a("ul",[a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("React如何处理key：\n当React使用index作为key时，列表项的顺序变化会导致组件的key发生变化。React会认为每个组件都是不同的，因此可能会重新创建组件，而不是复用已有组件。\n潜在问题\n组件状态丢失：")])])])]),t._v(" "),a("p",[t._v("如果组件有内部状态（例如输入框的内容），使用index作为key会导致这些状态在列表重新排序或删除时丢失。举个例子：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setItems"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("value")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Item 1'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("value")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Item 2'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("value")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Item 3'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("使用index作为key，如果你删除第二项，第三项的index就会变成2。React会认为这是一个新的组件，旧的组件状态（如输入框的内容）就会丢失。")]),t._v(" "),a("p",[t._v("以下是一个"),a("a",{attrs:{href:"https://stackblitz.com/edit/vitejs-vite-ccgrg3?file=src%2FOverlap.tsx",target:"_blank",rel:"noopener noreferrer"}},[t._v("在线示例"),a("OutboundLink")],1),t._v(", 在示例中你可以看到如果你使用"),a("code",[t._v("item.key")]),t._v("作为key (Overlap.tsx文件第75行), 那么在move up和move down的时候, 每个OverlapItem中的overlapId这个state都不会改变，会随着你上移和下移一起跟着组件走, 但是如果你使用index作为key, 那么在move up和move down的时候, 每个OverlapItem中的overlapId不会随着OverlapItem组件走, 而是会随着index走, 这样就导致每个OverlapItem中的overlapId会随着上移和下移而改变, 这样就导致组件状态丢失。")]),t._v(" "),a("h2",{attrs:{id:"性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能问题"}},[t._v("#")]),t._v(" 性能问题：")]),t._v(" "),a("p",[t._v("React在处理列表时，依赖key来决定哪些节点需要更新。当使用index作为key时，每次列表更新（比如顺序变化）都会导致整个列表重新渲染，这会影响性能，特别是对于大列表。")]),t._v(" "),a("p",[t._v("错误的元素复用：")]),t._v(" "),a("p",[t._v("使用index作为key会导致React错误地复用元素。比如，假设有两个组件，分别显示Item 1和Item 2。如果交换顺序并使用index作为key，Item 1组件的内容会变成Item 2，而React可能会错误地复用组件，导致数据混乱。")]),t._v(" "),a("p",[t._v("解决方案\n为了避免这些问题，你可以尝试以下解决方案：")]),t._v(" "),a("p",[a("strong",[t._v("使用唯一标识作为key:")])]),t._v(" "),a("p",[t._v("最好使用能够唯一标识列表项的key，比如你的item.key。这样React能够正确地判断哪些元素发生了变化，并且优化更新过程。")]),t._v(" "),a("p",[a("strong",[t._v("保证key的稳定性:")])]),t._v(" "),a("p",[t._v("key应该是稳定且唯一的，这样React可以正确地追踪元素，而不会误认为是不同的组件。例如，你可以在后端生成唯一标识符，或者使用nanoid等库生成唯一标识。")]),t._v(" "),a("p",[t._v("修改后的代码示例\n假设你希望在排序后保留组件的状态和避免性能问题，可以继续使用item.key作为key，如下：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("OverlapItem\n    key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 item.key 作为 key")]),t._v("\n    data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    removeItem"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("removeItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    moveItemUp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("moveItemUp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    moveItemDown"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("moveItemDown"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("使用index作为key会在列表更新时导致组件状态丢失、性能问题和潜在的错误复用问题。最好使用唯一且稳定的key来帮助React正确地识别和更新组件。\n希望这些解释能帮助你理解为什么不推荐使用index作为key，以及推荐的解决方法。如果还有其他疑问，请随时提问！")])])}),[],!1,null,null,null);a.default=n.exports}}]);